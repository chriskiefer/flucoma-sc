TITLE:: FluidBufToKr
summary:: Helper pseudo UGen for reading data out of a buffer to a Kr stream
categories:: Libraries>FluidCorpusManipulation
related:: Classes/FluidKrToBuf

DESCRIPTION::
Helper pseudo UGen for reading data out of a buffer to a Kr stream. It only reads one-channel buffers, converting them to a Kr stream.

CLASSMETHODS::

METHOD:: kr
Initialize an instance of this pseudo UGen

ARGUMENT:: buffer
Either a link::Classes/Buffer:: object or an index opointing to a buffer that this pseudo UGen will read out of. Must be a one-channel buffer.

ARGUMENT:: startFrame
Offset of reading position in the buffer. The default is 0.

ARGUMENT:: numFrames
Number of frames to read from the buffer. Needs to be set, if buffer is not a code::Buffer:: object but a buffer index. If code::-1::, read whole buffer starting at code::startFrame::. The default is -1.

returns:: a Kr stream that has the same number of channels as frames in the link::Classes/Buffer::.

INSTANCEMETHODS::

EXAMPLES::

code::
// make a buffer with some data in it
~buf = Buffer.loadCollection(s,[0,1,2,3,4,7]);

// play it on the server and read out of this buffer!
(
{
	var sig = FluidBufToKr.kr(~buf);
	sig.poll;
}.play;
)

// =============== passing a buffer as an argument ======================

// create a synth that both writes into a buffer (with FluidKrToBuf) and reads
// out of the same buffer (with FluidBufToKr)
(
~synth = {
	arg buf = 999;
	FluidKrToBuf.kr(SinOsc.kr(Array.fill(5,{rrand(0.0,1.0)})),buf);

	// you need to specify the 5 so the synth here will know how many channels to make
	// the output proxy
	FluidBufToKr.kr(buf,numFrames:5).poll;
}.play;
// you should see all zeros! (unless your buffer #999 has something in it already!)
)

// ...then after it is running, instantiate the buffer
~buffer = Buffer.alloc(s,2);

// ...then send it to the buffer
~synth.set(\buf,~buffer);
// you should be able to see the sine oscillators now!
::